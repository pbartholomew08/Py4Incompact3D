# Copyright 2018 Georgios Deskos, Paul Bartholomew
# Copyright 2021 University of Edinburgh
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use
# this file except in compliance with the License. You may obtain a copy of the
# License at http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software distributed
# under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
# CONDITIONS OF ANY KIND, either express or implied. See the License for the
# specific language governing permissions and limitations under the License.

import py4incompact3d

import os
from warnings import warn

import numpy as np
from mpi4py import MPI

import decomp2d

class Field():

    def __init__(self, *args, **kwargs):

        super().__init__()
        
        self.dtype = np.float64 # Default to double precision
        self.fromfile = True # By default load from a file

        if len(args) == 1:
            warn("You are using an old-style initialisation, the future is dynamic!", DeprecationWarning)

            instance_dictionary = args[0]
            
            self.name = instance_dictionary["name"]
            self.description = instance_dictionary["description"]

            properties = instance_dictionary["properties"]

            self.file_root = properties["filename"]
            self.direction = properties["direction"]

            if "precision" in properties:
                if properties["precision"] == "single":
                    self.dtype = np.float32
                else:
                    self.dtype = np.float64

            if "fromfile" in properties:
                self.fromfile = properties["fromfile"]
        else:
            for arg, val in kwargs.items():
                if arg == "name":
                    self.name = val
                elif arg == "description":
                    self.description = val
                elif arg == "file_root":
                    self.file_root = val
                elif arg == "direction":
                    self.direction = val
                elif arg == "precision":
                    if val == "single":
                        self.dtype = np.float32
                    else:
                        self.dtype = np.float64
                elif arg == "io_name":
                    self.io_name = val

        # decomp2d.decomp4py.register_variable(self.name, self.io_name)

        self.fh = None
        self.data = {}

    def _read(self, filename, nx, ny, nz, dtype=np.float64):
        """ Reads a datafile generated by Incompact3D into a (3D) numpy array. 
        
        :param filename: The file to read.
        :param nx: The mesh x resolution.
        :param ny: The mesh y resolution.
        :param nz: The mesh z resolution.
        :param dtype:
        """
        
        N = nx * ny * nz
        with open(filename, "rb") as bindat:
            fldat = np.fromfile(bindat, dtype)
            assert(len(fldat) == N)
            
        return np.reshape(fldat, (nx, ny, nz), "F")
    
    def _read_hdf5(self, t, nx, ny, nz):
        """ Reads a datafile generated by Incompact3D into a (3D) numpy array. 
        
        :param t:  The timestep to load.
        :param nx: The mesh x resolution.
        :param ny: The mesh y resolution.
        :param nz: The mesh z resolution.
        """
        import h5py # XXX: This doesn't seem right...
        
        N = nx * ny * nz
        with h5py.File(self.file_root, "r") as h5dat:
            h5path = "/Step" + str(t) + "/" + self.name
            arr = h5dat[h5path]
            fldat = np.zeros(arr.shape)
            arr.read_direct(fldat)
            fldat = fldat.flatten("F")
            assert(len(fldat) == N)

        return np.reshape(fldat, (nx, ny, nz), "C")

    def _read_mpiio(self, filename, nx, ny, nz, pencil="x", dtype=np.float64, io_name="solution-io"):
        """ Reads a datafile generate by Incompact3D into a (3D) numpy array in parallel.
        
        :param filename: The file to read.
        :param nx: The mesh x resolution.
        :param ny: The mesh y resolution.
        :param nz: The mesh z resolution.
        :param dtype:
        """

        subsizes = decomp2d.decomp4py.get_grid_size("x")
        data_path, data_file = os.path.split(filename)
        data_arr = np.zeros(subsizes, order="F")
        decomp2d.decomp4py.read_field(1, data_arr, data_path, data_file, io_name)
        return np.reshape(data_arr, subsizes, "C")

    def _read_adios2(self, t, nx, ny, nz):
        """ Use ADIOS2 interface. """

        global_size, local_size, start = decomp2d.decomp4py.get_io_extents(1)

        # Note, data comes in in Fortran order - need to read as though transposed
        startf = np.flip(start)
        local_sizef = np.flip(local_size)
        data = self.fh.read(self.name, start=startf, count=local_sizef)

        # Reshape our local data to conform to C-ordering
        return np.reshape(np.ravel(data, order="F"),
                          local_size,
                          order="C")
    
    def _read_adios2decomp(self, t, nx, ny, nz):
        """ Use ADIOS2 via 2decomp. """
        
        filename = os.path.join(self.file_root.split(".")[0], self.name)
        print(f"Trying to read {filename}/{t}")
        return self._read_mpiio(filename, nx, ny, nz)
    
    def _to_fortran(self, time=-1):
        """ Converts data fields from internal (C) to Fortran ordering.
        
        :param time: The time(s) to convert.
        :type time: int or list of int
        """

        if time == -1:
            conv_times = self.data.keys()
        elif isinstance(time, int):
            conv_times = [time]
        elif isinstance(time, list):
            conv_times = time
        else:
            raise ValueError

        for t in conv_times:
            self.data[t] = np.swapaxes(self.data[t], 0, 2)

    def _from_fortran(self, time=-1):
        """ Converts data fields from Fortran to internal (C) ordering.

        :param time: The time(s) to convert.
        :type time: int or list of int
        """

        if time == -1:
            conv_times = self.data.keys()
        elif isinstance(time, int):
            conv_times = [time]
        elif isinstance(time, list):
            conv_times = time
        else:
            raise ValueError

        for t in conv_times:
            self.data[t] = np.swapaxes(self.data[t], 2, 0)

    def load(self, mesh, time=-1):
        """ Loads a datafield timeseries.

        :param mesh: The mesh the data is stored on.
        :param time: Time(s) to load data, default value -1 means load all times.

        :type mesh: py4incompact3d.postprocess.mesh.Mesh
        :type time: int or list of int
        """
        read_hdf5 = False
        read_adios = False
        
        # Find all files to load
        if time == -1:
            load_times = range(1000) # This corresponds to 4-digit timestamp
        elif isinstance(time, int):
            load_times = [time]
        elif isinstance(time, list):
            load_times = time
        else:
            raise ValueError

        def suffix(s, sep="."):
            return s.split(sep)[-1]

        def is_hdf5(filename):
            sfx = suffix(filename)
            return sfx == "hdf5"
        
        def is_adios2(filename):
            adios2_suffixes = ["bp4", "bp5", "sst"]
            sfx = suffix(filename)
            return (sfx in adios2_suffixes) or is_hdf5(filename)

        if (py4incompact3d.HAVE_ADIOS2):
            read_adios = is_adios2(self.file_root)
        elif (py4incompact3d.HAVE_HDF5):
            import h5py # XXX: This doesn't seem right...
            if h5py.is_hdf5(self.file_root):
                read_hdf5 = True
            else:
                print(f"{self.file_root} is not an HDF5 file")

        print(self.file_root)
        print(read_adios, read_hdf5)
        if read_adios:

            filename = self.file_root.split(".")[0]
            filext = self.file_root.split(".")[-1]
            if (filext == "sst") and (not py4incompact3d.HAVE_ADIOS2PY):
                print("In-situ reader requires Python-enabled ADIOS2!")
                exit(-1)
                
            for t in load_times:
                if py4incompact3d.HAVE_ADIOS2PY:
                    self.data[t] = self._read_adios2(t, mesh.Nx, mesh.Ny, mesh.Nz)
                else:
                    self.data[t] = self._read_adios2decomp(t, mesh.Nx, mesh.Ny, mesh.Nz)
            
        elif read_hdf5:
            for t in load_times:
                self.data[t] = self._read_hdf5(t, mesh.Nx, mesh.Ny, mesh.Nz)
        else:
            for t in load_times:
                zeros = ""
                read_success = False
                while (not read_success) and (len(zeros) < 10):
                    try:
                        filename = self.file_root + zeros + str(t)
                        if (py4incompact3d.size == 1):
                            self.data[t] = self._read(filename, mesh.Nx, mesh.Ny, mesh.Nz, self.dtype)
                        else:
                            self.data[t] = self._read_mpiio(filename, mesh.Nx, mesh.Ny, mesh.Nz, self.dtype)
                    except FileNotFoundError:
                        msg = "Could not read " + filename + ", " + self.file_root + ", " + str(t)
                        print(msg)
                        zeros += "0"
                    else:
                        read_success = True

                if not read_success:
                    raise RuntimeError

    def new(self, mesh, pencil=0, time=0):

        self.data[time] = np.zeros((mesh.NxLocal[pencil], mesh.NyLocal[pencil], mesh.NzLocal[pencil]),
                                   dtype=self.dtype)
        
    def _get_timestamp(self, t, timestamp_len=3):
        """ Set the timestamp for output according to format: phiXXX where XXX is the time
        left-padded with zeros.

        :param t: The time.
        :param timestep_len: The desired length of the timestamp.

        :type t: int
        :type timestep_len: int

        :returns: timestamp
        :rtype: str
        """

        timestamp = str(t)
        nzeros = timestamp_len - len(timestamp)
        if nzeros >= 0:
            timestamp = "0" * nzeros + timestamp
        else:
            msg = "Timestamp ({}) too short to format time {}".format(str(timestamp_len), str(t))
            raise RuntimeError(msg)

        return timestamp

    def write(self, time, timestamp_len=3):
        """ Output to binary file.

        :param time: The time(s) to write out to.
        :param timestep_len: How long should the timestep be? A length of 3 gives timestep 1 as 001,
        10 as 010 etc.

        :type time: int or list of int
        :type timestep_len: int
        """

        if time == -1:
            write_times = self.data.keys()
        elif isinstance(time, int):
            write_times = [time]
        elif isinstance(time, list):
            write_times = time
        else:
            raise ValueError

        for t in write_times:
            filename = self.file_root + self._get_timestamp(t, timestamp_len)

            # Dump to raw binary, numpy writes in 'C' order so we need to shuffle our
            # array so that 'C' order looks like 'Fortran' order...
            self._to_fortran(t)
            self.data[t].tofile(filename)

            # Shuffle back to 'C' order incase we want to keep working with the array
            self.data[t] = self._from_fortran(t)

    def clear(self):
        """ Cleanup data. """
        self.data= {}
        
